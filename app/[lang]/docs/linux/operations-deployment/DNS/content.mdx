
# DNS란?
> You don't get what you wish for. You get what you work for.

Domain Name System(**DNS**)은 인터넷에서 사람이 읽을 수 있는 도메인 이름을 컴퓨터가 읽을 수 있는 IP 주소로 변환하는 분산형 데이터베이스 시스템입니다.

인터넷에 연결된 모든 컴퓨터에는 고유한 IP 주소가 있습니다. IP 주소는 숫자의 집합으로 이루어져 있으며, 사람이 기억하기 어렵습니다.   
따라서 인터넷을 사용하기 쉽게 하기 위해 도메인 이름이 사용됩니다. 도메인 이름은 사람이 이해하기 쉬운 문자열로 이루어져 있으며, IP 주소에 매핑됩니다.

예를 들어, `google.com`은 "142.250.190.142"이라는 IP 주소에 매핑됩니다. 따라서 사용자가 `google.com`을 입력하면 DNS 시스템은 이를 "142.250.190.142"으로 변환하여 해당 IP 주소에 연결합니다.

### DNS는 다음과 같은 단계로 작동합니다.
1. 사용자는 브라우저에 도메인 이름을 입력합니다.
2. 브라우저는 DNS 서버에 도메인 이름에 대한 정보를 요청합니다.
3. DNS 서버는 도메인 이름에 대한 정보를 검색합니다.
4. DNS 서버는 도메인 이름에 해당하는 IP 주소를 사용자에게 반환합니다.
5. 브라우저는 IP 주소를 사용하여 해당 컴퓨터에 연결합니다.  
DNS는 인터넷에서 매우 중요한 역할을 합니다. DNS가 없다면 사용자는 IP 주소를 입력해야 하기 때문에 인터넷을 사용하기 매우 어려울 것입니다.

### DNS는 다음과 같은 기능을 제공합니다.

* 도메인 이름과 IP 주소의 매핑
* 웹사이트에 대한 접근
* 이메일 전송
* 네트워크 서비스 검색
DNS는 분산형 데이터베이스 시스템입니다. 즉, DNS 서버는 전 세계에 분산되어 있으며, 각 서버는 특정 도메인 이름에 대한 정보를 저장합니다. 이렇게 하면 DNS 서버의 부하를 분산하고, 단일 DNS 서버의 장애에 대비할 수 있습니다.

DNS는 인터넷의 필수 요소이며, 인터넷의 효율적이고 안정적인 운영에 기여하고 있습니다.

## DNS Zone?
DNS zone은 도메인 이름 시스템에서 특정 조직이나 관리자가 관리하는 DNS 네임스페이스의 특정 부분입니다.  
DNS zone은 신뢰할 수 있는 이름 서버와 같은 DNS 구성 요소를 보다 세밀하게 제어할 수 있는 관리 공간입니다.
예로 `google.com`

DNS zone은 다음과 같은 두 가지 유형으로 나눌 수 있습니다.
* **기본 zone**: 기본 zone은 도메인 이름의 최상위 수준을 나타냅니다. 예를 들어, "example.com"은 기본 zone입니다
* **하위 zone**: 하위 zone은 기본 zone에 속하는 하위 수준 도메인을 나타냅니다. 예를 들어, "www.example.com"은 "example.com"의 하위 zone입니다.

DNS zone은 DNS 서버에 저장된 텍스트 파일인 **zone 파일**로 구성됩니다.  
zone 파일에는 해당 zone의 도메인 이름, IP 주소, 서버의 이름 등과 같은 정보가 포함되어 있습니다.

### DNS zone의 목적.

* **도메인 이름과 IP 주소의 매핑**: DNS zone은 도메인 이름과 IP 주소의 매핑 정보를 저장합니다. 이를 통해 사용자는 도메인 이름을 입력하여 해당 IP 주소에 연결할 수 있습니다.
* **도메인 이름의 관리**: DNS zone은 도메인 이름의 관리를 단순화합니다. DNS zone 관리자는 zone 파일을 통해 도메인 이름의 IP 주소, 서버의 이름 등과 같은 정보를 변경할 수 있습니다.
* **DNS 서버의 부하 분산**: DNS zone은 DNS 서버의 부하를 분산하는 데 도움이 됩니다. DNS zone을 여러 DNS 서버에 분산하여, 각 DNS 서버에 적절한 도메인 이름의 정보를 저장할 수 있습니다.
DNS zone은 인터넷에서 매우 중요한 역할을 합니다. DNS zone을 통해 도메인 이름과 IP 주소의 매핑을 효율적으로 관리하고, DNS 서버의 부하를 분산할 수 있습니다.

### Zone 파일
Zone 파일은 각 Zone의 정보와 Zone 내의 Record 정보들을 기술한 텍스트 파일이다. 이 파일은 DNS 서버에 존재하며 설정 파일 및 정보를 제공하는 데이터베이스와 같은 역할을 한다. Zone 파일은 DNS의 마스터 - 슬레이브 설정 시, 슬레이브가 DNS 설정 복제(replication)을 위해 마스터에서 주기적으로 업데이트 여부를 확인하고, 업데이트가 있다면 가져오는 정보이기도 하다.
- 자체적으로 DNS를 운영하는 경우, Zone 파일은 /var/named/userdomainname.com.zone 와 같은 경로에서 얻을 수 있다.
- 도메인 Registrar를 통해 관리하는 고객이라면 해당 서비스가 제공하는 Zone 파일 export 기능으로 쉽게 얻을 수 있다. 
Zone 파일은 결국 DNS Zone에 대해 SOA(Start of Authority) 레코드와 해당 zone에 포함된 서브 도메인들의 Resource 레코드 값을 정의한 텍스트 파일이다.  
(자세한 정보는 [RFC 1035](https://tools.ietf.org/html/rfc1035) 참고할 것)
[출처] DNS(Domain Name System) Zone을 이해하자|작성자 테크유람



## Named
`named`는 DNS 서버의 데몬 프로세스로, BIND(Berkeley Internet Name Domain) 프로젝트의 일부입니다.  
BIND 프로젝트는 DNS 서버를 구축하는 데 사용되는 가장 널리 사용되는 오픈 소스 소프트웨어입니다.  

### Configuration
- `named`는 `/etc/named.conf` 파일을 사용하여 구성됩니다.   
- 기본적으로 `/var/named` 디렉토리에 있는 zone 파일을 사용하여 도메인 이름에 대한 정보를 저장합니다.  
- `/var/run/named/named.pid`: 기본 PID 파일


### DNS Zone 파일의 구조
Zone 파일은 DNS Zone에 대한 SOA(Start of Authority) 레코드와 해당 zone에 포함된 서브 도메인들의 Resource 레코드 값을 정의한 텍스트 파일이다.  
자 어떻게 구성할 수 있을까? 가장 먼저 `/etc/named.conf` 파일을 열어보자.  
`/etc/named.conf` 파일은 다음과 같은 구조를 가진다.
```bash
options {
  # This line specifies the working directory for the server.
  directory "/var/named";
  # These lines specify various files used for dumping the server's cache, logging statistics, etc.
  dump-file "/var/named/data/cache_dump.db";
  statistics-file "/var/named/data/named_stats.txt";
  memstatistics-file "/var/named/data/named_mem_stats.txt";
  recursing-file "/var/named/data/named.recursing";
  secroots-file "/var/named/data/named.secroots";
  #  This line specifies that only the localhost can query this DNS server.
  allow-query { localhost; };
  recursion yes;
  # These lines enable DNSSEC (Domain Name System Security Extensions), which adds security to the DNS protocol by enabling DNS responses to be validated.
  dnssec-enable yes;
  dnssec-validation yes;
  dnssec-lookaside auto;
  # /* Path to ISC DLV key */
  # This line specifies the file containing the keys for DNSSEC lookaside validation.
  bindkeys-file "/etc/named.iscdlv.key";
  managed-keys-directory "/var/named/dynamic";
};
#  channel logs to the file data/named.run with a dynamic severity level.
logging {
  channel default_debug {
    file "data/named.run";
    severity dynamic;
  };
};
# . The type is set to hint, which means this is a hints file that lists the root servers. The file named.ca contains these hints.
zone "." IN {
  type hint;
  file "named.ca";
};

# "example.com" 도메인에 대한 DNS zone의 설정
zone "example.com" IN {
  # 이 DNS 서버가 "example.com" 도메인에 대한 마스터 서버임을 지정합니다. 마스터 서버는 도메인에 대한 정보의 주요 출처이며, 도메인의 DNS 레코드 변경을 관리합니다.
  type master;
  # 도메인에 대한 DNS 레코드를 포함하는 파일을 지정합니다. 
  file "example.com.zone";
  # DNS 레코드에 대한 변경이 "example.com.zone" 파일을 수동으로 편집함으로써만 이루어질 수 있음을 의미합니다.
  allow-update { none; };
};
include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";

```
처음 파일을 작성할 때 국룰은, 템플릿 파일을 찾아 가져오는 것이다. 데몬 서비스가 실행 할 수 있도록 권한 그대로 복사해오자.  
```bash
$ sudo ls /var/named
$ sudo cp --preserve=ownership /var/named/named.localhost /var/named/example.com.zone
$ cat /var/named/example.com.zone  
```


localhost Zone 파일은 다음과 같은 구조를 가진다.
```sh
# TTL(Time To Live)은 DNS Resource Record의 캐시 유지 시간을 의미한다. 즉, 해당 Resource Record의 캐시 유지 시간을 설정한다. TTL은 초 단위로 설정하며, 86400은 1일을 의미한다.
# 1D or 1d or 1H or 1h or 1M or 1m or 1S or 1s
$ TTL 86400
@ IN SOA @ administrator.example.com. (
  2019010101 ; Serial(시리얼 번호, -  zone 파일이 변경 될때마다 증가시켜야 한다. 10자리 이하의 숫자로 표현한다.)
  3600 ; Refresh(캐시된 zone 파일을 다시 읽어들이는 주기, 초 단위, 마스터 체크 주기)
  1800 ; Retry (마스터 서버와의 연결이 끊겼을 때, 마스터 서버에 재연결을 시도하는 주기, 초 단위)
  604800 ; Expire (7일, Zone 파일이 만료되었다고 판단하는 시간, 초 단위)
  86400 ; Minimum TTL (캐시된 zone 파일의 최소 유지 시간, 초 단위)
)
# name server, hey u can find dns data for example
@ IN NS ns1.example.com.
# 일반적으로 다음과 같은 경우에도 작동하는지 확인하기 위해 두 개의 이름 서버가 사용됩니다.(omit IN)
@ NS ns2.example.com.
# ns1.example.com 도메인의 IP 주소
ns1 IN A 10.11.12.9
ns2 IN A 10.11.12.10
# example.com 에 접속했을때 203.0.113.15 의 내 어플리케이션에 접속시키기 위한 정보
@   A 203.0.113.15
# www.example.com 으로 접근 했을때 리다이렉션 시키기 위한 정보
www CNAME 203.0.113.15 

# 다른 서버에 이메일을 어디로 보내야 하는지 알려줍니다.
# mail exchanger record, tells other servers where they should send their emails.
example.com. MX 10 mail.example.com.
             MX 20 mail.example.com.
# main server 에 대한 IP 주소, 4개의 4바이트 블록으로 구성된 32비트의 주소체계
mail A 203.0.113.80
mai2 A 203.0.113.81

# ipv6 4개의 16진수 블록으로 구성된 128비트의 주소체계
server1 AAAA 2001:db8:10::1
# 안에는 어떤 종류의 텍스트라도 들어있습니다.
# txt record, can contain any kind of text
@ TXT "v=spf1 mx -all"
example.com. TXT "We can write anything here"

# AAAA ::1
```
**참고 사항**
- @ : @는 현재 zone의 이름을 의미한다. 즉, 현재 zone의 이름은 example.com이다.
- IN : IN은 Internet을 의미한다. 즉, Internet에서 사용되는 Resource Record를 의미한다.
  - Internet 외에도 CSNET, CHAOS, HESIOD 등의 Resource Record가 존재하기는 한다;
- SOA : SOA는 Start of Authority를 의미한다. SOA는 해당 zone에 대한 정보를 제공한다. SOA는 zone 파일의 첫 번째 레코드이며, zone 파일에는 하나의 SOA만 존재한다.
- administrator.example.com: administrator@example.com 도메인의 메일 주소를 의미한다. 즉, example.com 도메인의 관리자이다.

- NS : NS는 Name Server를 의미한다. NS는 해당 zone에 대한 네임 서버 정보를 제공한다. NS는 SOA 다음에 위치하며, zone 파일에는 하나 이상의 NS가 존재한다.
- A : A는 Address를 의미한다. A는 도메인 이름과 IP 주소의 매핑 정보를 제공한다. A는 NS 다음에 위치하며, zone 파일에는 하나 이상의 A가 존재한다.
- CNAME : CNAME은 Canonical Name을 의미한다. CNAME은 도메인 이름의 별칭을 제공한다. CNAME은 A 다음에 위치하며, zone 파일에는 하나 이상의 CNAME이 존재한다.
- MX : MX는 Mail Exchanger를 의미한다. MX는 도메인 이름의 메일 서버 정보를 제공한다. MX는 CNAME 다음에 위치하며, 두번째 컬럼은 우선순위를 의미한다. 
- PTR : PTR은 Pointer를 의미한다. PTR은 IP 주소의 도메인 이름 정보를 제공한다. PTR은 MX 다음에 위치하며, zone 파일에는 하나 이상의 PTR이 존재한다.
- TXT : TXT는 Text를 의미한다. TXT는 도메인 이름에 대한 추가 정보를 제공한다. TXT는 PTR 다음에 위치하며, zone 파일에는 하나 이상의 TXT가 존재한다.
- SRV : SRV는 Service를 의미한다. SRV는 도메인 이름의 서비스 정보를 제공한다. SRV는 TXT 다음에 위치하며, zone 파일에는 하나 이상의 SRV가 존재한다.
- AAAA : AAAA는 IPv6 Address를 의미한다. AAAA는 도메인 이름과 IPv6 주소의 매핑 정보를 제공한다. AAAA는 SRV 다음에 위치하며, zone 파일에는 하나 이상의 AAAA가 존재한다.
- NAPTR : NAPTR은 Naming Authority Pointer를 의미한다. NAPTR은 도메인 이름의 추가 정보를 제공한다. NAPTR은 AAAA 다음에 위치하며, zone 파일에는 하나 이상의 NAPTR이 존재한다.
- DS : DS는 Delegation Signer를 의미한다. DS는 DNSSEC(DNS Security Extensions)에 사용되는 서명 정보를 제공한다. DS는 NAPTR 다음에 위치하며, zone 파일에는 하나 이상의 DS가 존재한다.
- DNSKEY : DNSKEY는 DNS Public Key를 의미한다. DNSKEY는 DNSSEC에 사용되는 공개 키 정보를 제공한다. DNSKEY는 DS 다음에 위치하며, zone 파일에는 하나 이상의 DNSKEY가 존재한다.
- RRSIG : RRSIG는 Resource Record Signature를 의미한다. RRSIG는 DNSSEC에 사용되는 서명 정보를 제공한다. RRSIG는 DNSKEY 다음에 위치하며, zone 파일에는 하나 이상의 RRSIG가 존재한다.
- NSEC : NSEC는 Next Secure을 의미한다. NSEC는 DNSSEC에 사용되는 서명 정보를 제공한다. NSEC는 RRSIG 다음에 위치하며, zone 파일에는 하나 이상의 NSEC가 존재한다.

이제 재시작 해보자.
```bash
$ sudo systemctl restart named
$ sudo systemctl status named
```
이제 DNS 서버가 example.com 도메인에 대한 정보를 제공할 수 있습니다.
테스트 해봅시다.
```bash
$ dig @localhost example.com
$ dig @localhost mail
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;example.com.			IN	A

;; ANSWER SECTION:
example.com.		86400	IN	A 203.0.113.15

;; AUTHORITY SECTION:
example.com.		86400	IN	NS ns1.example.com.
example.com.		86400	IN	NS ns2.example.com.

;; ADDITIONAL SECTION:
ns1.example.com.	86400	IN	A 10.11.12.9
ns2.example.com.	86400	IN	A 10.11.12.10
```
참고로 사용가능한  DNS 서버는 다음과 같이 확인할 수 있습니다.
```bash
$ cat /etc/resolv.conf | grep nameserver
```
하지만 @localhost는 특별한 지시자로  시스템은 자체 DNS 서버를 사용하여 DNS 조회를 수행하게 됩니다. 이는 주로 로컬 DNS 서버를 테스트하거나 디버깅할 때 유용합니다.  

---
```bash
$ dig google.com SOA

;; ANSWER SECTION:
google.com.		37	IN	SOA	ns1.google.com. dns-admin.google.com. 601989564 900 900 1800 60
```
음 구글의 nameserver는 ns1.google.com. 이다.

```bash
$ dig google.com

;; ANSWER SECTION:
google.com.		131	IN	A	142.251.222.206

;; SERVER: 127.0.0.53#53(127.0.0.53)
;; WHEN: Mon Jan 29 02:46:47 KST 2024
```
음 구글의 ip는 `142.251.222.206` 이군요
네임서버는 `ns1.google.com.` 이었었고.. 쿼리된 DNS 서버는 `127.0.0.53` 였었군..

# Practice

### Which is the configuration file of our Bind DNS server? 
`/etc/named.conf`

### Where does bind DNS server store all zone files on a RedHat based linux machine?
`/var/named/`

### What is the default port number of DNS server?
`53`

### Install bind DNS server on this system.
```bash
$ sudo yum install bind bind-utils
$ sudo dnf install bind bind-utils -y

```

### Configure the Bind daemon to accept queries from **any IP** on the Internet.   
Make sure to start named service after making required changes in the configuration.
```bash
# check keyword
$ apropos named
# check format
$ man named.conf

$ sudo vim /etc/named.conf

# 반드시 서브넷 형태로 넣어야한다;; 오바임
options {
  allow-query { 0.0.0.0/0; };

$ sudo systemctl restart named
```
### Query the local DNS server and identify the current `A` record value for `example.com` domain.   
(without updating any relevant configuration) and save the value in `/home/bob/a-record` file. (only the IP address)  

Query the local DNS server

응 ? 분명 `/var/named/example.com.zone` 와 값이 같아야 할텐데 왜 쿼리를 날리라고 하지? 굳이?  
```bash
$ sudo cat /var/named/example.com.zone

@               NS      ns1.example.com.
@               NS      ns2.example.com.
ns1             A       10.11.12.9
ns2             A       10.11.12.10
@               A       203.0.113.15
```
음 쿼리도 날려볼까
```bash
$ dig @localhost example.com
;; ANSWER SECTION:
example.com.            86254   IN      A       93.184.216.34
echo '93.184.216.34' > /home/bob/a-record
```
다르네?? 다음문제에 나온다.


### You might have noticed that in the previous question, the A record value for `example.com` domain is different what we have in `/var/named/example.com.zone` DNS zone file. Which means, this file isn't in use yet or DNS server hasn't read it yet.
Make the required changes so that the local zone file changes can take effect.

---
check current zone file
```bash
$ cat /var/named/example.com.zone
@               NS      ns1.example.com.
@               NS      ns2.example.com.
ns1             A       10.11.12.9
ns2             A       10.11.12.10
@               A       203.0.113.15
```


```bash
# check correctly applied
$ sudo vi /etc/named.conf 
# insert 
zone "example.com" IN {
        type master;
        file "example.com.zone";
};

$ sudo systemctl restart named
```
다시 `dig` 해보면 싱크되었다 >< 



### Modify `/var/named/example.com.zone` and add a new entry so that this subdomain `database.example.com` has this IP address: `1.2.3.4`
음 서브도메인(database)을 추가하면 되는 문제다.  
entry 와 그에 대한 ip를 추가하면 된다.  

```bash
$ echo 'database IN A 1.2.3.4' | sudo tee -a /var/named/example.com.zone
$ sudo systemctl restart named
$ dig @localhost database.example.com
```

### Modify `/var/named/example.com.zone` and make `mysql.example.com` an alias for `database.example.com` by adding the proper CNAME entry.  
Otherwise said, mysql.example.com should point to `database.example.com`.
mysql.example.com 을 database.example.com 으로 리다이렉션 시키는 문제다.  
친절히 CNAME까지 알려주니 걍 받아먹자.  `dig` 사용시 database.example.com 의 ip(`1.2.3.4`)가 나오면 된다.

```bash
$ echo 'mysql CNAME database' | sudo tee -a /var/named/example.com.zone
$ sudo systemctl restart named
$ dig @localhost mysql.example.com
```

### By default the bind server also fetches DNS data from other DNS servers on the Internet, when it does not have it available in its own cache. But somehow our bind server is not able to query the `kodekloud.com` domain data.
> 기본적으로 바인드 서버는 자체 캐시에 사용할 수 없는 경우 인터넷의 다른 DNS 서버에서도 DNS 데이터를 가져옵니다. 어떻게 해도 바인드 서버가 `kodekloud.com`도메인 데이터를 쿼리할 수 없는 상태입니다.  

바인딩 서버가 인터넷의 다른 DNS 서버에서도 DNS 데이터를 가져올 수 있도록 필요한 구성을 변경합니다.
```bash
# not found
$ dig @localhost kodekloud.com
# founded from /etc/resolv.conf
$ dig 172.25.0.1 kodekloud.com
```
`@localhost` 에서 못 찾을경우 `/var/named/` 파일들을 모두 찾아볼 수 있도록
`recursion yes;` 를 추가한다.
```bash
$ sudo vi /etc/named.conf
# insert
options {
  recursion yes;
  ...
}
...
$ sudo systemctl restart named
```

### Using `dig` utility retrieve all record types (including MX, TXT etc) associated with our `example.com` domain and save the output in `/home/bob/records` file.

`dig`의 포맷:  `dig @server name type`  중 타입은 아래와 같다
- ANY: 모든 레코드를 반환합니다. 
- A: 도메인 이름과 IP 주소의 매핑 정보를 반환합니다.
- MX: 도메인 이름의 메일 서버 정보를 반환합니다.
- SIG: DNSSEC에 사용되는 서명 정보를 반환합니다.
- SOA: 해당 zone에 대한 정보를 반환합니다.
- TXT: 도메인 이름에 대한 추가 정보를 반환합니다.
- 뭐 이런 아까 나온 파일들의 타입들이다
```bash
$ man dig
$ dig @localhost example.com ANY > /home/bob/records
```

### Change the TTL for `example.com` domain to tell other DNS servers that, they may query our zone to cache this data for 2 hours.
> 다른 DNS 서버에게 2시간 동안 캐시할 수 있도록 `example.com` 도메인의 TTL을 변경합니다.

```bash
$ sudo vi /var/named/example.com.zone

$TTL 1H
@       IN SOA  @ administrator.example.com. (
의 TTL을 2H로 변경한다.
```


## References
* https://blog.naver.com/techtrip/222154620404
* https://en.wikipedia.org/wiki/SOA_record
* https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-creating-import.html